

Weekend:
	(Done) - Run the NURBS bump test case and verify that the solution converges. 
		Visualize the results.

		(Done) - Compare the metric and normal terms using the NURBS approach and normal 
			method. They should be of similar orders of magnitude

		- geom_coef seems to be a parameter that is used throughout the code. The issue is
			that this term is not found using the NURBS mapping. So, I am unsure of what 
			effect that is having on the solution.

	(Done) - Create a NACA 0012 airfoil patch

		(Done) - Use a B Spline to represent the airfoil. Perform a continuous least squares 
			approximation to find the location to place the control points at. Since
			a B Spline will be used for this, the weights of all control points should
			be 1.

		(Done) - Use a NURBS circle representation for the farfield (so we still have a NURBS
			patch we are working with). This will create a o-grid.

	(Done) - Run the NACA 0012 Airfoil Patch Case

		(Done) - Create the gmsh file to accompany the patch.

			(Done) - Create slip wall boundary conditions at the bottom, farfield
				at the top and then periodic at the line at which the patch
				touches each other at rear of the airfoil.

		(Done) - Set the case test parameters in solution.data (for the farfield conditions)

		(Done) - Add the correct function pointers in the code for the given test case

			(Done) - See where the reimann bc information is read. I believe it is from 
				boundary_euler_T.c as this function, based on the boundary condition,
				will read the solution.data file and use those parameters for setting
				the BC values.

		(Done) - Run the airfoil case and check whether the flow converges.

	- Create a boundary layer mesh for NACA airfoil case

		- Have the mesh be identical to the non-boundary layer version (in terms of
			boundary conditions) but now have more elements near the airfoil 
			surface. 

		- Rerun the cases for P2 and visualize the results

	- Verify implementation with Philip for the metric terms. We just need that 
		the metric terms are found using the NURBS mapping, that is all.

	- Figure out whats going on with the orders of accuarcy tests

	- Create a python plotting program for the orders case

		- Use as input parameters the test keyword as well as the mesh and p levels.
			Read the data directly from the errors folder (provide an absolute path)
			and plot the orders data.

	- Create the lift coefficient objective function.

		- Compute the lift by integrating the pressure on any face that had 
			a slip wall BC. Then just sum up all the contributions. 

		- Create a real version of the function first. Then, create 
			a templated version so that the function may be called
			with complex doubles (for the adjoint computation)

	- Compute the adjoint for the lift coefficient case.

		- Use the linearization of the LHS in the code

		- Compute the linearization of the RHS by using the complex step
			
			- Verify using finite differences. Create a unit test 
				to verify linearization with finite differences. 
				Eventually, perhaps, compute the linearization analytically

		- Solve the adjoint using PETSc

			- Output PETSc convergence for the adjoint solve

		- Plot the density adjoint variation

	- Create a python program for running cases without adaptation for the convergence
		test.

		- Take the test keyword as input along with the mesh levels. Note that the 
			cases will have to have been added to ctests for the test_integration_run
			case. 

		- Run each case using ctest and collect the results (this way we can get by
			the iffy aspects of mesh adaptation)

	- Complete orders of accuracy tests

		- When not using adaptation, the results for different mesh levels differ. This
			is not the case for the entropy L2 error however (for some reason). All other 
			L2 errors differ however (except for the first mesh level). Check with 
			Philip to see why this might be the case.

		(Done) - Include if statement in adaptation to handle the case where a NURBS geometry
			is being used and the metric terms should be found using the mapping

			(Done) - Check that orders hold for this case (NURBS mapping with adaptation)

			- Verify the validity of the placement/implementation with Philip

ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 

