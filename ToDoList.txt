
-----------------------------------------------------------------------------------------------------------------------------


NURBS Enhanced

Monday:

	(Done) - Check memory leaks by running valgrind for NLPQLP optimization case

	(Done) - Implement an optimization.data file reader. Place all optimization specific information in that file and read it
		before the start of each optimization case.

		(Done) - Place and read the BFGS optimization information

		(Done) - Place and read the NLPQLP optimization information

	(Done) - Modify the input into the objective functions

		(Done) - Change the file name to functionals 

		(Done) - Read the functional information from the optimization_data file.

	(Done) - In the output progress file, set the additional parameters to print by reading the optimization_data file and loading
		the information into a string

	(Done) - Implement the pitching moment computation

		(Done) - Place the pitching moment leading edge location in the .geo file and read it.

		(Done) - Adjust the xyz locations of the face nodes to now use the NURBS mapping and not the geom_coeff for the volumes

		(Done) - Implement the pitching moment computation

			(Done) - Run an optimization case and monitor the progression of the CM value

			- Seems to be good (NACA0012, Cm is 0 as expected initially and it becomes negative also as expected). Perhaps
				run more validation of this function.

		(Done) - Add the constraint data structure

			(Done) - Add a struct for holding the constraint information. Struct should hold possibly the function pointer to the
				constraint function, what type of constraint it is (equality, inequality), and, based on the type of constraint,
				what the RHS should be (less than what, greater than what, etc...)

		(Done) - Add the pitching moment constraint and put the data for the constraint into the optimization.data file. Try the target CL case
			with this constraint information.

			(Done) - Implement the pitching moment functional

			(Done) - Validate the gradient computation of the functional

			(Done) - Try an equality constraint optimization and see if the optimization works for P2. Try cm = -0.13 and a target cl of 0.24. Did not work very well.

			(Done) - Add the ability to print a prefix on the file names for a test case in order to organize the results.

			(Done) - Run a Target CL case with a small window for the cm pitching moment constraint. Run a P2 case

			(Done) - Try the isoparametric and superparametric case for P2 and see the convergence.
			
Tuesday:

	- Implement a percent volume change constraint. 

		- Test gradient of constraint function with brute force.

		- Try a target cl constrained optimization with the volume change constraint for the P2 case. Use an equality constraint.

		- Try the isoparametric and superparametric case for P2 and see the convergence. 

	- Implement Inverse Design Case (NACA 4412)

		- Run a really fine case first on the transformed grid and store the results in a file.

		- Will only be able to parametrize for geometries that have the same knot domain (-1 to 1). 

	- Run a Target CL constrained optimization with CM and Volume change constraints

		- Add function to, along with the standard output, output the gradient, dR_dXp, dI_dXp and Adjoint before the first design step

		- Run a P2 case with NURBS and both Standard - ml1

		- Run a P3 case with NURBS and both Standard - ml1

		- Compile results into plots and see what trends result. Compile plots into a pdf to perhaps send to the prof.

	- Template the objective function file to be able to have a real and complex version of the function.

	- Finalize clean up of implementation for optimization.

	- Investigate the metric issue with the NURBS and Standard mixed

		- Output the field of differences of the metrics to see how large the difference in the metric terms are throughout the 
			mesh. 

Wednesday:
	
	- Add metric computation section to journal paper.

	- Add grid deformation section to journal paper

	- Implement test case to see how conjugate gradient method works


-----------------------------------------------------------------------------------------------------------------------------


IGA-DG

Tuesday:
	
	- Complete reading Paper
	
Wednesday:

	- Implement the directory structure

	- Create the CMake files for the cases

	- Implement the matrix data structure classes. Template the class to be able to hold different types of matrices

Thursday:
	
	- Implement a mesh reader to be able to read a multi-patch DG mesh

	- Implement basis functions correctly (NURBS) so that they span over multiple elements.

-----------------------------------------------------------------------------------------------------------------------------


OVERALL GOALS: (For the end of the Summer - August 15)

(1) Complete all NURBS enhanced optimization cases and compile the results into a publishable paper on high-order adjoint-based shape optimization
	for the NURBS enhanced approach. One case should be read from a CAD file.

(2) Complete a multi-patch IGA-DG code and investigate the stability results. Study 1D and 2D cases. Compile the results into the final poster presentation.

(Optional) (3) Complete a multi-patch IGA-DG code with optimization using the discrete adjoint approach and the Euler equations. Compile the results into a publishable paper
	on high-order adjoint based shape optimization using Isogeometric Analysis. One case should be read from a CAD file.


-----------------------------------------------------------------------------------------------------------------------------












	- Check orders of convergence for NURBS enhanced case

	- Read the NURBS geometry information from the ctrl file now (no longer
		use a macro).

		- Remove all occurences of the Macro

	- Clean up implementation of the functions in bases.c/h and 
		geometry_parametric_T.c/h. 

		- Place doxygen style comments for functions. Move the comments from the src
			file to the header.


	- Generalize the face and volume cubature (NURBS metrics) to other elements (not just QUADS)

	- Remove NURBS_geometry from the macros file


Naming Convention:
	[initial_shape]_[optimization_type]_[P]_[ml/Dimension]_[NURBS_Metric]_[Optimizer_and_info]











	- Implement NURBS book derivative computation to see if that approach for 
			computing patch derivatives is faster.

	- Use the NURBS mapping with the efficient derivative computation to optimize the 
		given patch.

	- Try to get a transonic case running for the airfoil case with a shock
		(to be used potentially for a drag optimization)

	- Check implementation of metric terms (NURBS) to ensure that the NURBS 
		mapping is used for the metrics properly.

		- Compute xyz_fc now using the NURBS mapping (get around geom_coeff).

		- Set geom_coef to NULL or all zeros and ensure that the code still runs

			- In the plotting section, compute xyz_p values using the mapping

		- Check if the adaptation case is implemented correctly.


ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 
	- Template the objective function section

	- Create the optimization.data file from the NURBS patch generator

		- Add in the information for the type of optimization, so that we know which 
			objective function to set the function pointer to.

		- Add an option for what type of approach to use for the optimization (ex: BFGS, 
			steepest descent, NLPQLP). Read in this parameter from the file.

Optimization Cases:

	- Accompanying the .geo file will need to be an optimization.data file which will
		hold which NURBS control points should be treated as design variables and
		what their degrees of freedom are (use the control point indeces in the 
		.geo file)

	- Will set function pointers to the objective function to be used in the 
		optimization. This way, can easily switch between optimizing one 
		objective to another. If each objective is templated properly, then
		computing the partials of the objective will be simple.

			- Simply, take as input to the function the pointer to the objective
				function and then perform all the complex steps to find all the
				terms of the RHS and sensitivity equation terms.

			- Return a multiarray with the data (RHS and sensitivity equation terms)






