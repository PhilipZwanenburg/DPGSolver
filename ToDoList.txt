
Wednesday:

	(Done) - Modify the configure files to be able to build the code by creating the parameter file.

	(Done) - Trace through code to see adjustments after the merge:

		(Done) - Trace through geometry_T.c to see changes and validate them.

		(Done) - Trace through geometry_parametric_T.c to see changes and to validate them.

	(Done) - Build the code

	(Done) - Run the test cases to ensure they pass (non NURBS).

	- Fix templating for NURBS geometry

		(Done) - Create a real and complex version of the NURBS mapping function 
			(to get the coordinates). Implement the templating using TYPE_RC for now

		- Implement NURBS mapping case without NURBS metrics (use isoparametric
			mapping). Verify real and complex versions of mappings work.
			Run the test_integration_run case to verify.

		- Create a real and complex version of the NURBS grad function (to get the 
			gradients).

		- Template the xyz mapping function for the NURBS mapping.

		- Template the grad mapping function for the NURBS mapping.

	- Check test_integration_run for NURBS case

	- Check orders of convergence for NURBS enhanced case

	- Read the NURBS geometry information from the ctrl file now (no longer
		use a macro).

		- Remove all occurences of the Macro

	- Clean up implementation of the functions in bases.c/h and 
		geometry_parametric_T.c/h. 

		- Place doxygen style comments for functions. Move the comments from the src
			file to the header.



	- Run the NURBS optimization cases to see if they converge still.

	- Read the IGA Paper

Monday:

	- Write the Methodology section for the paper.

	- Plan out IGA implementation.












	- Run Valgrind to check memory leaks with NLPQLP

	- Perform unconstrained NLPQLP optimization

		- Complete P2 results (20 x 10 grid) with NURBS metrics

		- Complete P2 results (20 x 10 grid) without NURBS metrics

	- Implement the Pitching Moment computation
		
	- Create poster with thesis results

	- Clean up code optimization structure with NLPQLP

	- Remove NURBS_geometry from the macros file


Naming Convention:
	[initial_shape]_[optimization_type]_[P]_[ml/Dimension]_[NURBS_Metric]_[Optimizer_and_info]











	- Implement NURBS book derivative computation to see if that approach for 
			computing patch derivatives is faster.

	- Use the NURBS mapping with the efficient derivative computation to optimize the 
		given patch.

	- Try to get a transonic case running for the airfoil case with a shock
		(to be used potentially for a drag optimization)

	- Check implementation of metric terms (NURBS) to ensure that the NURBS 
		mapping is used for the metrics properly.

		- Compute xyz_fc now using the NURBS mapping (get around geom_coeff).

		- Set geom_coef to NULL or all zeros and ensure that the code still runs

			- In the plotting section, compute xyz_p values using the mapping

		- Check if the adaptation case is implemented correctly.


ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 
	- Template the objective function section

	- Create the optimization.data file from the NURBS patch generator

		- Add in the information for the type of optimization, so that we know which 
			objective function to set the function pointer to.

		- Add an option for what type of approach to use for the optimization (ex: BFGS, 
			steepest descent, NLPQLP). Read in this parameter from the file.

Optimization Cases:

	- Accompanying the .geo file will need to be an optimization.data file which will
		hold which NURBS control points should be treated as design variables and
		what their degrees of freedom are (use the control point indeces in the 
		.geo file)

	- Will set function pointers to the objective function to be used in the 
		optimization. This way, can easily switch between optimizing one 
		objective to another. If each objective is templated properly, then
		computing the partials of the objective will be simple.

			- Simply, take as input to the function the pointer to the objective
				function and then perform all the complex steps to find all the
				terms of the RHS and sensitivity equation terms.

			- Return a multiarray with the data (RHS and sensitivity equation terms)






