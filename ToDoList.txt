	(Done) - Create a test for the optimization run similar to test_integration_run

	(Done) - Create the lift coefficient objective function.

		(Done) - Compute the lift by integrating the pressure on any face that had 
			a slip wall BC. Then just sum up all the contributions. 

	(Done) - Create an Optimization data structure

		(Done) - Create a typedef function pointer for the objective function (make a target CL
			objective function). Make a function pointer to a real version and complex
			version of the function.

		(Done) - Make the function pointer in the optimization data structure point to the 
			real objective function.

		(Done) - Test typedef function pointer to make sure it returns the value of the function
			properly.

	(Done) - Create the complex version of the objective functions (will template later)

	(Done) - Compute adjoint RHS using complex step

		(Done) - Loop over only the volumes that have a boundary face (for now, implement it 
			as if the target Cl objective is being used).

		(Done) - Apply complex perturbation to the state vector components

		(Done) - Compute each term of the RHS using this approach.

	(Done) - Use the real version of the implementation o compute the adjoint

		(Done) - Use finite differences to obtain the terms of the RHS. 

	(Done) - Compare results to the finite difference approach.

	(Done) - Solve the Adjoint equation

		(Done) - Take the transpose of the LHS and solve the equation to find the adjoint

	(Done) - Use valgrind to fix all memory leaks up until now in the implementation

	(Done) - Generate the design variable point connectivity (and their dofs). Place this in
		the .geo file. It will only be used by the optimization routines.

	(Done) - In the optimization setup, read all the geo_data data. 

	(Done) - Create a method for updating geo_data which will update the geo_data struct information 
			using the data held in optimization_case.

	(Done) - Create a modified grad_NURBS_xyz to make it more efficient in terms
		of B Spline calls. 

	(Done) - Create a modified NURBS_xyz to make it more efficient in terms of the
		number of B Spline calls.

	(Done) - Compute the sensitivities using finite differences

		(Done) - Compute the objective function linearization with respect to the design
				control points.

		(Done) - Compute the Residual linearization with respect to the design control 
				points. 

	(Done) - Compute the gradient of the objective function using the adjoint and the 
		sensitivity equation.

	(Done) - Compute the gradient of the objective function using a brute force algorithm.

		(Done) - Ensure values obtained is equivalent to the adjoint approach.

	(Done) - Use valgrind to check to make sure there are no memory leaks.

	(Done) - Use steepest descent to converge to an optimal solution.
		-> Solution didn't converge by getting there (slowly). Will mvoe onto BFGS and NLPQLP

	(Done) - Implement BFGS and use it to converge to an optimal solution.

	(Done) - Create a 20 x 10 grid and see how well the flow resolves on it

	(Done) - Write Python plotter and add output for convergence so that it can be 
		plotted to see how the convergence progressed.

	(Done) - Write Python spline plotter to visualize the optimal solutions 

	(Done) - Do P2 flow convergence on 16 x 10 grid

		(Done) - Complete the results with NURBS Metrics

		(Done) - Complete the results without NURBS Metrics

		- Complete the results without NURBS Metrics Superparametric

		(Done) - Plot and store results in folder

	(Done) - Do P3 flow convergence on 20 x 10 grid

		(Done) - Complete the results with NURBS Metrics

		(Done) - Complete the results without NURBS Metrics

	(Done) - Implement the NLPQLP wrapper into the code

		(Done) - Complete input file writing function

		(Done) - Complete output file processing function

		(Done) - Complete coupling with NLPQLP and see one design iteration

	- Run Valgrind to check memory leaks with NLPQLP

	- Perform unconstrained NLPQLP optimization

		- Complete P2 results (20 x 10 grid) with NURBS metrics

		- Complete P2 results (20 x 10 grid) without NURBS metrics

	- Implement the Pitching Moment computation
		
	- Create poster with thesis results

	- Clean up code optimization structure with NLPQLP


Naming Convention:
	[initial_shape]_[optimization_type]_[P]_[ml/Dimension]_[NURBS_Metric]_[Optimizer_and_info]











	- Implement NURBS book derivative computation to see if that approach for 
			computing patch derivatives is faster.

	- Use the NURBS mapping with the efficient derivative computation to optimize the 
		given patch.

	- Try to get a transonic case running for the airfoil case with a shock
		(to be used potentially for a drag optimization)

	- Check implementation of metric terms (NURBS) to ensure that the NURBS 
		mapping is used for the metrics properly.

		- Compute xyz_fc now using the NURBS mapping (get around geom_coeff).

		- Set geom_coef to NULL or all zeros and ensure that the code still runs

			- In the plotting section, compute xyz_p values using the mapping

		- Check if the adaptation case is implemented correctly.


ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 
	- Template the objective function section

	- Create the optimization.data file from the NURBS patch generator

		- Add in the information for the type of optimization, so that we know which 
			objective function to set the function pointer to.

		- Add an option for what type of approach to use for the optimization (ex: BFGS, 
			steepest descent, NLPQLP). Read in this parameter from the file.

Optimization Cases:

	- Accompanying the .geo file will need to be an optimization.data file which will
		hold which NURBS control points should be treated as design variables and
		what their degrees of freedom are (use the control point indeces in the 
		.geo file)

	- Will set function pointers to the objective function to be used in the 
		optimization. This way, can easily switch between optimizing one 
		objective to another. If each objective is templated properly, then
		computing the partials of the objective will be simple.

			- Simply, take as input to the function the pointer to the objective
				function and then perform all the complex steps to find all the
				terms of the RHS and sensitivity equation terms.

			- Return a multiarray with the data (RHS and sensitivity equation terms)






