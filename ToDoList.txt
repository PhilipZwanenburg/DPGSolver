
Monday:

	(Done) - Clean up optimize.c

		(Done) - Clean up optimization_case.c/h

		(Done) - Clean up adjoint.c/h

		(Done) - Clean up sensitivities.c/h

		(Done) - Create a new file for computing the gradient. Should also have a constructor and destructor for
			a data structure that holds 

		(Done) - Get BFGS Optimization working with cleaned up structures

		(Done) - Run Valgrind on BFGS optimization to ensure there are no memory leaks

		(Done) - move the NLPQLP methods to a proper file (organize the structure)

	(Done) - Clean up optimization monitoring (make it standard so NLPQLP, BFGS, ... all use
		the same methods). 

	(Done) - Implement the progress output for the geometry

	(Done) - Run the NLPQLP optimization case to see that it still converges.

	(Done) - Implement the complex step sensitivities

		(Done) - Compute dR_dXp using the complex step

		(Done) - Compute dI_dXp using the complex step

		(Done) - Verify the final gradient values obtained and compare it to the brute force values

	(Done) - Run the NLPQLP optimization case with complex step sensitivities (NACA0012 airfoil target CL)

	(Done) - Compare final optimized profiles for all 3 cases (NURBS enhanced, Standard, Superparametric)

	- Plot and list the gradient values for the three cases

	- Check memory leaks by running valgrind for NLPQLP optimization case

	- Finalize clean up of implementation for optimization. Commit changes.

	- Implement the pitching moment computation

		- Plot the variation in the pitching moment to see how it varies in the optimization

	- Implement a pitching moment constraint and try to converge to an optimal solution (NLPQLP)

	- Template the objective function file to be able to have a real and complex version of the function







	- Check orders of convergence for NURBS enhanced case

	- Read the NURBS geometry information from the ctrl file now (no longer
		use a macro).

		- Remove all occurences of the Macro

	- Clean up implementation of the functions in bases.c/h and 
		geometry_parametric_T.c/h. 

		- Place doxygen style comments for functions. Move the comments from the src
			file to the header.



	- Run the NURBS optimization cases to see if they converge still.



	- Generalize the face and volume cubature (NURBS metrics) to other elements (not just QUADS)


	- Read the IGA Paper










	- Run Valgrind to check memory leaks with NLPQLP

	- Perform unconstrained NLPQLP optimization

		- Complete P2 results (20 x 10 grid) with NURBS metrics

		- Complete P2 results (20 x 10 grid) without NURBS metrics

	- Implement the Pitching Moment computation
		
	- Create poster with thesis results

	- Clean up code optimization structure with NLPQLP

	- Remove NURBS_geometry from the macros file


Naming Convention:
	[initial_shape]_[optimization_type]_[P]_[ml/Dimension]_[NURBS_Metric]_[Optimizer_and_info]











	- Implement NURBS book derivative computation to see if that approach for 
			computing patch derivatives is faster.

	- Use the NURBS mapping with the efficient derivative computation to optimize the 
		given patch.

	- Try to get a transonic case running for the airfoil case with a shock
		(to be used potentially for a drag optimization)

	- Check implementation of metric terms (NURBS) to ensure that the NURBS 
		mapping is used for the metrics properly.

		- Compute xyz_fc now using the NURBS mapping (get around geom_coeff).

		- Set geom_coef to NULL or all zeros and ensure that the code still runs

			- In the plotting section, compute xyz_p values using the mapping

		- Check if the adaptation case is implemented correctly.


ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 
	- Template the objective function section

	- Create the optimization.data file from the NURBS patch generator

		- Add in the information for the type of optimization, so that we know which 
			objective function to set the function pointer to.

		- Add an option for what type of approach to use for the optimization (ex: BFGS, 
			steepest descent, NLPQLP). Read in this parameter from the file.

Optimization Cases:

	- Accompanying the .geo file will need to be an optimization.data file which will
		hold which NURBS control points should be treated as design variables and
		what their degrees of freedom are (use the control point indeces in the 
		.geo file)

	- Will set function pointers to the objective function to be used in the 
		optimization. This way, can easily switch between optimizing one 
		objective to another. If each objective is templated properly, then
		computing the partials of the objective will be simple.

			- Simply, take as input to the function the pointer to the objective
				function and then perform all the complex steps to find all the
				terms of the RHS and sensitivity equation terms.

			- Return a multiarray with the data (RHS and sensitivity equation terms)






