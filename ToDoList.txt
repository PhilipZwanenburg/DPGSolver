
Wednesday:

	(Done) - Modify the configure files to be able to build the code by creating the parameter file.

	(Done) - Trace through code to see adjustments after the merge:

		(Done) - Trace through geometry_T.c to see changes and validate them.

		(Done) - Trace through geometry_parametric_T.c to see changes and to validate them.

	(Done) - Build the code

	(Done) - Run the test cases to ensure they pass (non NURBS).

	- Fix templating for NURBS geometry

		(Done) - Create a real and complex version of the NURBS mapping function 
			(to get the coordinates). Implement the templating using TYPE_RC for now

		(Done) - Implement NURBS mapping case without NURBS metrics (use isoparametric
			mapping). Verify real and complex versions of mappings work. Since complex
			version cannot be run, make sure metric terms are identical for real and 
			complex version.

		(Done) - Create a real and complex version of the NURBS grad function (to get the 
			gradients).

		(Done) - Template the xyz mapping function for the NURBS mapping.

		(Done) - Template the grad mapping function for the NURBS mapping.

		(Done) - Output the real and complex metric terms and compare for the NURBS metrics case

		(Done) - Output the real and complex metric terms and compare for the no NURBS metrics case

	(Done) - Check test_integration_run for NURBS enhanced case

	- Fix test_integration_optimization case

	- Clean up optimization case function

	- Clean up objective function file

	- Clean up adjoint function

	- Clean up sensitivity function

	- move the NLPQLP methods to a proper file (organize the structure)

	- Run the NLPQLP optimization case to see that it still converges.

	- Clean up optimization monitoring (make it standard so NLPQLP, BFGS, ... all use
		the same methods). 

	- Implement the complex step sensitivities

		- Verify that the difference between the complex step and finite difference is low

	- Run the NLPQLP optimization case with complex step sensitivities (NACA0012 airfoil target CL)

	- Compare final optimized profiles for all 3 cases (NURBS enhanced, Standard, Superparametric)

		- If results differ greatly, output gradient for all three cases for the first design step

		- Output the magnitude of each component in the gradient evaluation to see the difference there.

	- Implement the pitching moment computation

		- Plot the variation in the pitching moment to see how it varies in the optimization

	- Implement a pitching moment constraint and try to converge to an optimal solution (NLPQLP)

	- Template the objective function file to be able to have a real and complex version of the function






	- Check orders of convergence for NURBS enhanced case

	- Read the NURBS geometry information from the ctrl file now (no longer
		use a macro).

		- Remove all occurences of the Macro

	- Clean up implementation of the functions in bases.c/h and 
		geometry_parametric_T.c/h. 

		- Place doxygen style comments for functions. Move the comments from the src
			file to the header.



	- Run the NURBS optimization cases to see if they converge still.



	- Generalize the face and volume cubature (NURBS metrics) to other elements (not just QUADS)


	- Read the IGA Paper


CLOCK_IN  = 4:51
CLOCK_OUT = 6:30

TIME_ELAPSE = 3:58










	- Run Valgrind to check memory leaks with NLPQLP

	- Perform unconstrained NLPQLP optimization

		- Complete P2 results (20 x 10 grid) with NURBS metrics

		- Complete P2 results (20 x 10 grid) without NURBS metrics

	- Implement the Pitching Moment computation
		
	- Create poster with thesis results

	- Clean up code optimization structure with NLPQLP

	- Remove NURBS_geometry from the macros file


Naming Convention:
	[initial_shape]_[optimization_type]_[P]_[ml/Dimension]_[NURBS_Metric]_[Optimizer_and_info]











	- Implement NURBS book derivative computation to see if that approach for 
			computing patch derivatives is faster.

	- Use the NURBS mapping with the efficient derivative computation to optimize the 
		given patch.

	- Try to get a transonic case running for the airfoil case with a shock
		(to be used potentially for a drag optimization)

	- Check implementation of metric terms (NURBS) to ensure that the NURBS 
		mapping is used for the metrics properly.

		- Compute xyz_fc now using the NURBS mapping (get around geom_coeff).

		- Set geom_coef to NULL or all zeros and ensure that the code still runs

			- In the plotting section, compute xyz_p values using the mapping

		- Check if the adaptation case is implemented correctly.


ToDo:
	- Implement efficient NURBS mapping derivative using NURBS book 
		algorithm which gets around the use of the derivative of the
		basis functions.
	- Alternate approach of using the NURBS metric terms
		- Compute the metric terms using the NURBS mapping at the metric nodes. This will
				now form a basis that can be used to find the values at any other nodes. 
		- Issue is, how to get the geom_coef values using the metric terms.
			- Traditionally what is done: 
				- For the volume cubature nodes, we use an operator to go 
					from vm (volume metric) to vc (volume cubature). 
				- For the face, we once again interpolate from the vm (volume metric)
					to the fc (face cubature) nodes. 
	- Template the objective function section

	- Create the optimization.data file from the NURBS patch generator

		- Add in the information for the type of optimization, so that we know which 
			objective function to set the function pointer to.

		- Add an option for what type of approach to use for the optimization (ex: BFGS, 
			steepest descent, NLPQLP). Read in this parameter from the file.

Optimization Cases:

	- Accompanying the .geo file will need to be an optimization.data file which will
		hold which NURBS control points should be treated as design variables and
		what their degrees of freedom are (use the control point indeces in the 
		.geo file)

	- Will set function pointers to the objective function to be used in the 
		optimization. This way, can easily switch between optimizing one 
		objective to another. If each objective is templated properly, then
		computing the partials of the objective will be simple.

			- Simply, take as input to the function the pointer to the objective
				function and then perform all the complex steps to find all the
				terms of the RHS and sensitivity equation terms.

			- Return a multiarray with the data (RHS and sensitivity equation terms)






